/*
 * Slack Web API
 *
 * One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
 *
 * API version: 1.0.5
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package slack

import (
	"encoding/json"
	"golang.org/x/net/context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type ChatApiService service

/* ChatApiService
Deletes a message.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "asUser" (bool) Pass true to delete the message as the authed user with &#x60;chat:write:user&#x60; scope. [Bot users](/bot-users) in this context are considered authed users. If unused or false, the message will be deleted with &#x60;chat:write:bot&#x60; scope.
    @param "token" (string) Authentication token. Requires scope: &#x60;chat:write&#x60;
    @param "ts" (float32) Timestamp of the message to be deleted.
    @param "channel" (string) Channel containing the message to be deleted.
@return ChatDeleteSuccessSchema*/
func (a *ChatApiService) ChatDelete(ctx context.Context, localVarOptionals map[string]interface{}) (ChatDeleteSuccessSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     ChatDeleteSuccessSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["asUser"], "bool", "asUser"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["token"], "string", "token"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["ts"], "float32", "ts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["channel"], "string", "channel"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["token"].(string); localVarOk {
		localVarHeaderParams["token"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["asUser"].(bool); localVarOk {
		localVarFormParams.Add("as_user", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["ts"].(float32); localVarOk {
		localVarFormParams.Add("ts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["channel"].(string); localVarOk {
		localVarFormParams.Add("channel", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* ChatApiService
Retrieve a permalink URL for a specific extant message
* @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "token" (string) Authentication token. Requires scope: &#x60;none&#x60;
    @param "messageTs" (float32) A message&#39;s &#x60;ts&#x60; value, uniquely identifying it within a channel
    @param "channel" (string) The ID of the conversation or channel containing the message
@return ChatGetPermalinkSuccessSchema*/
func (a *ChatApiService) ChatGetPermalink(ctx context.Context, localVarOptionals map[string]interface{}) (ChatGetPermalinkSuccessSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     ChatGetPermalinkSuccessSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.getPermalink"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["token"], "string", "token"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["messageTs"], "float32", "messageTs"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["channel"], "string", "channel"); err != nil {
		return successPayload, nil, err
	}

	if localVarTempParam, localVarOk := localVarOptionals["token"].(string); localVarOk {
		localVarQueryParams.Add("token", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["messageTs"].(float32); localVarOk {
		localVarQueryParams.Add("message_ts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["channel"].(string); localVarOk {
		localVarQueryParams.Add("channel", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* ChatApiService
Share a me message into a channel.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "text" (string) Text of the message to send.
    @param "token" (string) Authentication token. Requires scope: &#x60;chat:write:user&#x60;
    @param "channel" (string) Channel to send message to. Can be a public channel, private group or IM channel. Can be an encoded ID, or a name.
@return DefaultSuccessTemplate*/
func (a *ChatApiService) ChatMeMessage(ctx context.Context, localVarOptionals map[string]interface{}) (DefaultSuccessTemplate, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     DefaultSuccessTemplate
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.meMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["text"], "string", "text"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["token"], "string", "token"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["channel"], "string", "channel"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["token"].(string); localVarOk {
		localVarHeaderParams["token"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["text"].(string); localVarOk {
		localVarFormParams.Add("text", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["channel"].(string); localVarOk {
		localVarFormParams.Add("channel", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* ChatApiService
Sends an ephemeral message to a user in a channel.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "attachments" (string) A JSON-based array of structured attachments, presented as a URL-encoded string.
    @param "text" (string) Text of the message to send. See below for an explanation of [formatting](#formatting). This field is usually required, unless you&#39;re providing only &#x60;attachments&#x60; instead.
    @param "linkNames" (bool) Find and link channel names and usernames.
    @param "parse" (string) Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](#formatting).
    @param "token" (string) Authentication token. Requires scope: &#x60;chat:write&#x60;
    @param "user" (string) &#x60;id&#x60; of the user who will receive the ephemeral message. The user should be in the channel specified by the &#x60;channel&#x60; argument.
    @param "asUser" (bool) Pass true to post the message as the authed bot. Defaults to false.
    @param "channel" (string) Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name.
@return ChatPostEphemeralSuccessSchema*/
func (a *ChatApiService) ChatPostEphemeral(ctx context.Context, localVarOptionals map[string]interface{}) (ChatPostEphemeralSuccessSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     ChatPostEphemeralSuccessSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.postEphemeral"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["attachments"], "string", "attachments"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["text"], "string", "text"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["linkNames"], "bool", "linkNames"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["parse"], "string", "parse"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["token"], "string", "token"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["user"], "string", "user"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["asUser"], "bool", "asUser"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["channel"], "string", "channel"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["token"].(string); localVarOk {
		localVarHeaderParams["token"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["attachments"].(string); localVarOk {
		localVarFormParams.Add("attachments", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["text"].(string); localVarOk {
		localVarFormParams.Add("text", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["linkNames"].(bool); localVarOk {
		localVarFormParams.Add("link_names", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["parse"].(string); localVarOk {
		localVarFormParams.Add("parse", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["user"].(string); localVarOk {
		localVarFormParams.Add("user", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["asUser"].(bool); localVarOk {
		localVarFormParams.Add("as_user", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["channel"].(string); localVarOk {
		localVarFormParams.Add("channel", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* ChatApiService
Sends a message to a channel.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "username" (string) Set your bot&#39;s user name. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.
    @param "threadTs" (float32) Provide another message&#39;s &#x60;ts&#x60; value to make this message a reply. Avoid using a reply&#39;s &#x60;ts&#x60; value; use its parent instead.
    @param "attachments" (string) A JSON-based array of structured attachments, presented as a URL-encoded string.
    @param "unfurlLinks" (bool) Pass true to enable unfurling of primarily text-based content.
    @param "text" (string) Text of the message to send. See below for an explanation of [formatting](#formatting). This field is usually required, unless you&#39;re providing only &#x60;attachments&#x60; instead.
    @param "unfurlMedia" (bool) Pass false to disable unfurling of media content.
    @param "parse" (string) Change how messages are treated. Defaults to &#x60;none&#x60;. See [below](#formatting).
    @param "asUser" (bool) Pass true to post the message as the authed user, instead of as a bot. Defaults to false. See [authorship](#authorship) below.
    @param "token" (string) Authentication token. Requires scope: &#x60;chat:write&#x60;
    @param "mrkdwn" (bool) Disable Slack markup parsing by setting to &#x60;false&#x60;. Enabled by default.
    @param "iconEmoji" (string) Emoji to use as the icon for this message. Overrides &#x60;icon_url&#x60;. Must be used in conjunction with &#x60;as_user&#x60; set to &#x60;false&#x60;, otherwise ignored. See [authorship](#authorship) below.
    @param "linkNames" (bool) Find and link channel names and usernames.
    @param "iconUrl" (string) URL to an image to use as the icon for this message. Must be used in conjunction with &#x60;as_user&#x60; set to false, otherwise ignored. See [authorship](#authorship) below.
    @param "channel" (string) Channel, private group, or IM channel to send message to. Can be an encoded ID, or a name. See [below](#channels) for more details.
    @param "replyBroadcast" (bool) Used in conjunction with &#x60;thread_ts&#x60; and indicates whether reply should be made visible to everyone in the channel or conversation. Defaults to &#x60;false&#x60;.
@return ChatPostMessageSuccessSchema*/
func (a *ChatApiService) ChatPostMessage(ctx context.Context, localVarOptionals map[string]interface{}) (ChatPostMessageSuccessSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     ChatPostMessageSuccessSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.postMessage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["username"], "string", "username"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["threadTs"], "float32", "threadTs"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["attachments"], "string", "attachments"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["unfurlLinks"], "bool", "unfurlLinks"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["text"], "string", "text"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["unfurlMedia"], "bool", "unfurlMedia"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["parse"], "string", "parse"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["asUser"], "bool", "asUser"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["token"], "string", "token"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["mrkdwn"], "bool", "mrkdwn"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["iconEmoji"], "string", "iconEmoji"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["linkNames"], "bool", "linkNames"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["iconUrl"], "string", "iconUrl"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["channel"], "string", "channel"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["replyBroadcast"], "bool", "replyBroadcast"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["token"].(string); localVarOk {
		localVarHeaderParams["token"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["username"].(string); localVarOk {
		localVarFormParams.Add("username", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["threadTs"].(float32); localVarOk {
		localVarFormParams.Add("thread_ts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["attachments"].(string); localVarOk {
		localVarFormParams.Add("attachments", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["unfurlLinks"].(bool); localVarOk {
		localVarFormParams.Add("unfurl_links", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["text"].(string); localVarOk {
		localVarFormParams.Add("text", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["unfurlMedia"].(bool); localVarOk {
		localVarFormParams.Add("unfurl_media", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["parse"].(string); localVarOk {
		localVarFormParams.Add("parse", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["asUser"].(bool); localVarOk {
		localVarFormParams.Add("as_user", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["mrkdwn"].(bool); localVarOk {
		localVarFormParams.Add("mrkdwn", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["iconEmoji"].(string); localVarOk {
		localVarFormParams.Add("icon_emoji", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["linkNames"].(bool); localVarOk {
		localVarFormParams.Add("link_names", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["iconUrl"].(string); localVarOk {
		localVarFormParams.Add("icon_url", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["channel"].(string); localVarOk {
		localVarFormParams.Add("channel", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["replyBroadcast"].(bool); localVarOk {
		localVarFormParams.Add("reply_broadcast", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* ChatApiService
Provide custom unfurl behavior for user-posted URLs
* @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "userAuthMessage" (string) Provide a simply-formatted string to send as an ephemeral message to the user as invitation to authenticate further and enable full unfurling behavior
    @param "userAuthRequired" (bool) Set to &#x60;true&#x60; or &#x60;1&#x60; to indicate the user must install your Slack app to trigger unfurls for this domain
    @param "unfurls" (string) URL-encoded JSON map with keys set to URLs featured in the the message, pointing to their unfurl message attachments.
    @param "ts" (string) Timestamp of the message to add unfurl behavior to.
    @param "userAuthUrl" (string) Send users to this custom URL where they will complete authentication in your app to fully trigger unfurling. Value should be properly URL-encoded.
    @param "token" (string) Authentication token. Requires scope: &#x60;links:write&#x60;
    @param "channel" (string) Channel ID of the message
@return ChatUnfurlSuccessSchema*/
func (a *ChatApiService) ChatUnfurl(ctx context.Context, localVarOptionals map[string]interface{}) (ChatUnfurlSuccessSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     ChatUnfurlSuccessSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.unfurl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["userAuthMessage"], "string", "userAuthMessage"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["userAuthRequired"], "bool", "userAuthRequired"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["unfurls"], "string", "unfurls"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["ts"], "string", "ts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["userAuthUrl"], "string", "userAuthUrl"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["token"], "string", "token"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["channel"], "string", "channel"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["token"].(string); localVarOk {
		localVarHeaderParams["token"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["userAuthMessage"].(string); localVarOk {
		localVarFormParams.Add("user_auth_message", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["userAuthRequired"].(bool); localVarOk {
		localVarFormParams.Add("user_auth_required", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["unfurls"].(string); localVarOk {
		localVarFormParams.Add("unfurls", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["ts"].(string); localVarOk {
		localVarFormParams.Add("ts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["userAuthUrl"].(string); localVarOk {
		localVarFormParams.Add("user_auth_url", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["channel"].(string); localVarOk {
		localVarFormParams.Add("channel", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}

/* ChatApiService
Updates a message.
* @param ctx context.Context for authentication, logging, tracing, etc.
@param optional (nil or map[string]interface{}) with one or more of:
    @param "attachments" (string) A JSON-based array of structured attachments, presented as a URL-encoded string. This field is required when not presenting &#x60;text&#x60;.
    @param "text" (string) New text for the message, using the [default formatting rules](/docs/formatting). It&#39;s not required when presenting &#x60;attachments&#x60;.
    @param "ts" (float32) Timestamp of the message to be updated.
    @param "parse" (string) Change how messages are treated. Defaults to &#x60;client&#x60;, unlike &#x60;chat.postMessage&#x60;. See [below](#formatting).
    @param "asUser" (bool) Pass true to update the message as the authed user. [Bot users](/bot-users) in this context are considered authed users.
    @param "token" (string) Authentication token. Requires scope: &#x60;chat:write&#x60;
    @param "linkNames" (bool) Find and link channel names and usernames. Defaults to &#x60;none&#x60;. This parameter should be used in conjunction with &#x60;parse&#x60;. To set &#x60;link_names&#x60; to &#x60;1&#x60;, specify a &#x60;parse&#x60; mode of &#x60;full&#x60;.
    @param "channel" (string) Channel containing the message to be updated.
@return ChatUpdateSuccessSchema*/
func (a *ChatApiService) ChatUpdate(ctx context.Context, localVarOptionals map[string]interface{}) (ChatUpdateSuccessSchema, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		successPayload     ChatUpdateSuccessSchema
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/chat.update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if err := typeCheckParameter(localVarOptionals["attachments"], "string", "attachments"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["text"], "string", "text"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["ts"], "float32", "ts"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["parse"], "string", "parse"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["asUser"], "bool", "asUser"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["token"], "string", "token"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["linkNames"], "bool", "linkNames"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["channel"], "string", "channel"); err != nil {
		return successPayload, nil, err
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarTempParam, localVarOk := localVarOptionals["token"].(string); localVarOk {
		localVarHeaderParams["token"] = parameterToString(localVarTempParam, "")
	}
	if localVarTempParam, localVarOk := localVarOptionals["attachments"].(string); localVarOk {
		localVarFormParams.Add("attachments", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["text"].(string); localVarOk {
		localVarFormParams.Add("text", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["ts"].(float32); localVarOk {
		localVarFormParams.Add("ts", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["parse"].(string); localVarOk {
		localVarFormParams.Add("parse", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["asUser"].(bool); localVarOk {
		localVarFormParams.Add("as_user", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["linkNames"].(bool); localVarOk {
		localVarFormParams.Add("link_names", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["channel"].(string); localVarOk {
		localVarFormParams.Add("channel", parameterToString(localVarTempParam, ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return successPayload, localVarHttpResponse, err
	}
	defer localVarHttpResponse.Body.Close()
	if localVarHttpResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHttpResponse.Body)
		return successPayload, localVarHttpResponse, reportError("Status: %v, Body: %s", localVarHttpResponse.Status, bodyBytes)
	}

	if err = json.NewDecoder(localVarHttpResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHttpResponse, err
	}

	return successPayload, localVarHttpResponse, err
}
